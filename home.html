<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ff4444">
    <title>Topology Dashboard</title>
    <link rel="stylesheet" href="css/home.css">
    <script src = "js/geoxml3.js" ></script>
    <script src = "https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
</head>
<body>
<!-- ======= Header ======= -->
<header id="header">
    <div class="d-flex flex-column">
        <aside id="left-sidebar">
            <div class="sidebar-content">
                <img src="media/luceor_logo.png" alt="Luceor Logo">

                <h2>Create Your Network Topology</h2>
                <div class = "first-options">
                    <button id="new_project">New project</button>
                    <button id="old_project">Import existing project</button>
                </div>

                <div class="upload_kml_file" style="display: none;" >
                    <form enctype="multipart/form-data">
                        <input id="file" name="file" type="file" />
                        <button  type="button" id="upload_file">Upload KML file</button>
                    </form>
                </div>
                
                <div class="upload_json_file" style="display: none;" >
                    <input type="file" id="importFromFile" accept=".json" />
                    <button id="importButton" >Upload Json File</button>
                </div>

                <div id="layer-controls"></div>
                <div id="layer-control" style="display: none;">
                    <h2>Select Source and Destination Layers</h2>
                    <div class="source-layers">
                        <label for="sourceLayers">Source Layers:</label>
                        <select id="sourceLayers" name="sourceLayers" multiple required>
                        </select>
                    </div>
                    <div class="dest-layers">
                        <label for="destLayers">Destination Layers:</label>
                        <select id="destLayers" name="destLayers" multiple required>
                        </select>
                    </div>
                    <button type="button" id="processLayers">Process Layers</button>
                </div>
                <div class="max_dist_threshold" style="display: none;">
                    <label for="distanceSlider">Select Distance (km):</label>
                    <input type="range" id="distanceSlider" min="1" max="100" value="50" step="1">
                    <span id="distanceValue">50 km</span>
                    <button type="button" id="submit_thresh">Submit threshold</button>
                </div>
                <div class="other_buttons" style="display: none;">
                    <button id="saveToLocalStorage" >Save to Local Storage</button>
                    <button id="exportToFile" >Export to File</button>
                </div>
                <div class="topology-container" style="display: none;" >
                    <button type="button" id="generate-topology">Generate Topology</button>
                </div>
                <div class="antenna_characteristics" style="display: none;">
                    <button type="button" id="generate-characteristics">Topology characteristics</button>
                </div>
                <div class="download_button"  style="display: none;">
                    <button type="button" id="download_button">Download Topology</button>
                </div>
            </div>
        </aside>
    </div>
    <section id="sensorContainer" class="flex-container">
        <div id="map-container" class="map-container">
            <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBeya4HQeQc6Ps1nROlox3qrQV3fbrJRAc&v=beta&libraries=drawing&callback=initMap"></script>
        </div>
        <div id="loading-spinner" style="display:none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;">
            <div class="spinner"></div>
        </div>
        <div id="line-info" style="display: none;">
            <span id="line-information"></span> 
            <canvas id="elevation-chart"></canvas>
            <button id="close-line-info">âœ–</button>
        </div>
    </section>
</header>
<div id="myModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Antenna Parameters</h2>
        <table id="antennaTable">
            <thead>
                <tr>
                    <th>Node Id</th>
                    <th>Name</th>
                    <th>Router Type</th>
                    <th>Roles</th>
                    <th>horizontal Azimuth</th>
                    <th>Vertical Azimuth</th>
                    <th>Channel</th>
                </tr>
            </thead>
            <tbody id="antennaTableBody">
            </tbody>
        </table>
    </div>
</div>

<script>
    let map;
    let elevator;
    let drawingManager;
    let markers = [];
    let lines   = [];
    let triangles= [];
    let positions = [];
    let positions_map = [];
    let desired_rates = [];
    let chartInstance;
    let generateTopologyClicked = false;
    let marker1 = null;
    let marker2 = null;
    let drawingModeEnabled = false;
    let channel_colors = {};
    let bandwidth = 20*1e6;
    let available_channels = [52, 100];
    let roles = [];
    let horizontal_azimuths =[];
    let vertical_azimuths=[];
    let router_type =[];
    let channel_links = [];
    let upload  =false;
    let path_elevations = [];
    let distances       = [];
    let marker_index    =  new Map();
    let dist_thresh     = 0;
    let total_labels    = [];
    let samples         = 30;
    let final_connections = [];
    let sz_src;
    let obligatory_nodes = [];
    let node_capacities  = [];
    let total_markers    = [];
    let position_labels  = [];
    let layers_positions = {};
    let layers_positions_map ={}; 
    let markers_name_per_layer = {};
    let marker_names = [];
    let connections      = [];
    let layers           = { };
    let layerControls    = {};
    let xmlContent       = '';
    let xmlDoc ;
    let global_max_threshold = 10;
    let globalVariable;
    let new_project = true;
    const position = { lat: 24.6986413, lng: 44.0534141 };


    async function initMap() {

        function handleMarkerClick(marker) {
            if (!marker1) {
                marker1 = marker;
            } else if (!marker2) {
                marker2 = marker;
                if (marker1.getPosition().lat != marker2.getPosition().lat  ||   marker1.getPosition().lng != marker2.getPosition().lng){
                    drawLineBetweenMarkers(marker1, marker2)
                }
                marker1 = null;
                marker2 = null;
            }
        }

        function drawLineBetweenMarkers(marker1, marker2) {
            const path = [marker1.getPosition(), marker2.getPosition()];
            const line = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: '#ff0000',
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map,
            });
            lines.push(line); 
            google.maps.event.addListener(line, 'click', function() {
                plot_elevation_data(marker1,marker2);
            });
        }

        function plot_elevation_data(marker1, marker2){
            console.log(marker_index);
            const start_index = marker_index.get(`${marker1.getPosition().lat()},${marker1.getPosition().lng()}`);
            const end_index   = marker_index.get(`${marker2.getPosition().lat()},${marker2.getPosition().lng()}`);
            console.log("start_index", start_index,"end_index", end_index);
            const dist  =  distances[start_index][end_index];
            const elevationData = path_elevations[start_index][end_index];
            const labels = Array.from({ length:samples}, (_, k) => Math.floor((dist / (samples-1) * k )));
            const initial_height = positions[start_index][2];
            const last_height    = positions[end_index][2];     
            const pathData = Array.from({ length:samples}, (_, k) => (((last_height - initial_height)/ (samples-1) ) * k + initial_height ));     
            const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples-1) * k ) * (dist -(dist / (samples-1) * k )) * 0.06/ dist))))); 
            showLineInfo(`distance :${dist} km`, elevationData,fresnelData,pathData,labels);
        }

        function readXMLFile(file) {
            var reader = new FileReader();
            reader.onload = function(e) {
                xmlContent = e.target.result;
                parseXML(xmlContent);
            };
            reader.readAsText(file);
        }

        
        async function parseXML(xmlContent) {
            const parser = new DOMParser();
            xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            console.log(xmlDoc);
            
            const folderColors = {
                'TOTEM_SA': 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
                'SITEs': 'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png',
                'RDA': 'http://maps.google.com/mapfiles/ms/icons/orange-dot.png',
                'Internet Source': 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png'
            };
            layers = {}; // Reset layers
            layers_positions_map = {}; // Reset layers_positions_map
            layers_positions = {}; // Reset layers_positions
            markers_name_per_layer = {};
            markers = []; // Reset markers array
        
            // Find all Folder elements
            const folders = xmlDoc.getElementsByTagName('Folder');
            console.log(`Found ${folders.length} folders`);
        
            // Process folders asynchronously
            for (const folder of folders) {
                const folderName = folder.getElementsByTagName('name')[0].textContent;
                const folderColor = folderColors[folderName];
                if (!layers[folderName]) {
                    layers[folderName] = [];
                    addLayerControls(folderName);
                    populateLayerOptions(folderName); // Populate select options
                }
                const placemarks = folder.getElementsByTagName('Placemark');
                // Process placemarks asynchronously
                for (const placemark of placemarks) {
                    const name = placemark.getElementsByTagName('name')[0].textContent;
                    const coordinates = placemark.getElementsByTagName('coordinates')[0].textContent.trim().split(',');
                    const latitude = parseFloat(coordinates[1]);
                    const longitude = parseFloat(coordinates[0]);
                    const maxHeightElement = placemark.querySelector('SimpleData[name="Maximum Height (m)"]');
                    var antenna_height = maxHeightElement ? parseFloat(maxHeightElement.textContent) : 5;
                    if (new_project){
                        var elevation = await getElevation({ lat: latitude, lng: longitude });
                        elevation += antenna_height;
                        if (!layers_positions_map[folderName]) {
                            layers_positions_map[folderName] = [];
                        }
                        if (!markers_name_per_layer[folderName]) {
                            markers_name_per_layer[folderName] = [];
                        }
                        if (!layers_positions[folderName]) {
                            layers_positions[folderName] = [];
                        }
                        layers_positions_map[folderName].push({ lat: latitude, lng: longitude });
                        layers_positions[folderName].push([latitude, longitude, elevation]);
                        markers_name_per_layer[folderName].push(name);
                    }
                    const marker = new google.maps.Marker({
                        position: { lat: latitude, lng: longitude },
                        map: null, // Map will be added later
                        title: name,
                        icon: {
                            url: folderColor,
                            scaledSize: new google.maps.Size(40, 40)
                        }
                    });
                    layers[folderName].push(marker);
                    marker.addListener('click', function() {
                        if (drawingModeEnabled) {
                            handleMarkerClick(marker);
                        } 
                    });
                    markers.push(marker);
                }
            }
        }

        function addLayerControls(folderName) {
            var controlContainer = document.createElement('div');
            var control = document.createElement('input');
            control.type = 'checkbox';
            control.id = folderName;
            control.checked = false; 
            control.addEventListener('change', function() {
                updateLayerVisibility(folderName, this.checked);
            });
            var label = document.createElement('label');
            label.htmlFor = folderName;
            label.appendChild(document.createTextNode(folderName));
            // Append the control and label to the container
            controlContainer.appendChild(control);
            controlContainer.appendChild(label);
            // Append the container to the main layer controls container
            var container = document.getElementById('layer-controls'); // Assuming you have a container for controls
            container.appendChild(controlContainer);
            layerControls[folderName] = control;
        }
        
        function updateLayerVisibility(folderName, isVisible) {
            if (layers[folderName]) {
                layers[folderName].forEach(function(marker) {
                    marker.setMap(isVisible ? map : null); // Show or hide the marker based on layer visibility
                });
            }
        }

        function populateLayerOptions(folderName) {
            // Populate Source Layers
            var sourceLayerSelect = document.getElementById('sourceLayers');
            var option = document.createElement('option');
            option.value = folderName;
            option.textContent = folderName;
            sourceLayerSelect.appendChild(option);
            // Populate Destination Layers
            var destLayerSelect = document.getElementById('destLayers');
            var option2 = document.createElement('option');
            option2.value = folderName;
            option2.textContent = folderName;
            destLayerSelect.appendChild(option2);
        }
        
        function isLayerVisible(folderName) {
            return layerControls[folderName] && layerControls[folderName].checked;
        }

        async function getElevation(loc) {
            console.log(loc);
            try {
                const { results } = await elevator.getElevationForLocations({
                    locations: [loc],
                });
        
                if (results[0]) {
                    const elevation = results[0].elevation;
                    console.log("elevation", elevation);
                    return elevation;
                } else {
                    console.log("Can't get the elevation for this point");
                    return 0; // Return 0 in case of an error
                }
            } catch (error) {
                console.error('Elevation request failed', error);
                return 0; // Return 0 in case of an error
            }
        }
        
        function fill_connections() {
            let sz = positions.length;    
            let possible_conns = Array.from({ length: sz }, () => []);
            console.log(final_connections)
            for (let i = 0; i < sz - 1; i++) {
                console.log("node_index",i);
                for (let j of final_connections[i]) {
                    if (distances[i][j] <= dist_thresh) {
                            console.log(j)
                            if (!possible_conns[i].includes(j)) {
                                possible_conns[i].push(j);
                            }
                            if (!possible_conns[j].includes(i)) {
                                possible_conns[j].push(i);
                            }
                    }
                }
            }
            console.log("final_connections", possible_conns)
            return possible_conns;
        }
    
        function possible_links(sz_src) {
            let sz1 = positions.length;
            let total_connections = Array.from({ length: sz1 }, () => []); // Initialize with empty arrays
            for (let i = 0; i < sz1; ++i) {
                    if (total_labels[i] === 'SITEs'  || total_labels[i] === 'RDA'){
                        obligatory_nodes.push(i);
                    }
                for (let j = Math.max(i + 1, sz_src); j < sz1; ++j) {
                    // Find the start and end positions in the positions_map
                    let pathClear = true;
                    let dst = distances[i][j];
                    if (dst <= global_max_threshold) {
                        const path_elevation = path_elevations[i][j];
                        const elevationStart = positions[i][2];
                        const elevationEnd = positions[j][2];
                        const labels = Array.from({ length: path_elevation.length }, (_, k) => (dst / (samples-1) * k ));
                        for (let k = 1; k < path_elevation.length - 1; k++) {
                            let elevation = path_elevation[k];
                            let interpolatedElevation  = elevationStart + ((elevationEnd - elevationStart) * (k / (samples -1) ));
                            // TO ACTIVATE THE FRESNEL ZONE VERIFICATION
                            // interpolatedElevation -=  (17.32 * Math.sqrt(((dst / (samples-1) * k ) * (dst -(dist / (samples-1) * k ) * 0.06/ dst);
                            if (elevation >= interpolatedElevation) {
                                pathClear = false;
                                break;
                            }
                        }
                        if (pathClear) {
                            total_connections[i].push(j);
                            total_connections[j].push(i);
                        }
                    } 
                }
            }
        
            return total_connections;
        }

        async function fill_matrices() {
            try {
                // Define the API endpoint
                const apiEndpoint = 'http://127.0.0.1:3000/fill-matrices';
                // Make the POST request to the Flask API
                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        positions_map: positions_map,
                        samples: samples,
                    }),
                });
                // Check if the response is ok (status code 200-299)
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                // Parse the JSON response
                const data = await response.json();
                // Extract distances and path elevations from the response
                distances = data.distances;
                path_elevations = data.path_elevations;
                // Handle the API response
                console.log('Distances:', distances);
                console.log('Path Elevations:', path_elevations);
            } catch (error) {
                // Handle errors
                console.error('Error calling Flask API:', error);
        
                // Optionally, return a default value or rethrow the error
                return { distances: [], path_elevations: [] };
            }
        }
        

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function symmetricPoint(center, point) {
            return {
                lat: 2 * center.lat - point.lat,
                lng: 2 * center.lng - point.lng
            };
        }

        
        async function handleGenerateTopology(event) {
             // Clear all lines from the map
             for (let line of lines) {
                line.setMap(null);
            }
            lines = [];
        
            // Clear all triangles from the map
            for (let triangle of triangles) {
                triangle.setMap(null);
            }
            triangles = []
            roles = [];
            horizontal_azimuths= [];
            vertical_azimuths = []
            channel_links  =[];
            available_channels.forEach(channel => {
                channel_colors[channel] = getRandomColor();
            });
            const formData = {
                "n": sz_src,
                "positions": positions,
                "labels": total_labels,
                "distances": distances,
                "obligatory_nodes": obligatory_nodes,
                "possible_connections": connections, 
                "node_capacities": node_capacities,
                "bandwidth": bandwidth ,
                "available_channels": available_channels
            };
            console.log(formData);
            await fetch('http://localhost:5000/generate_topology', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(formData),
            })
            .then(response => {
                if (!response.ok) {
                        throw new Error(`Server returned status: ${response.status}`);
                }
                return response.json();
            })
            .then( async response => {
                
                if (response.state ){
                    roles= []
                    horizontal_azimuths = [];
                    vertical_azimuths = [];
                    channel_link = [];
                    router_type = [];
                    generateTopologyClicked = true;
                    const topology = response.node_tree;
                    const connections = response.node_list;
                    const rates = response.data_list;
                    const capacities = response.capacities;
                    const consumed_rates = response.consumed_rates;
                    const channel_array = response.channel_array;
                    const connection_boundaries = response.connection_boundaries;
                    const horizontal_azimuth = response.horizontal_azimuth;
                    const vertical_azimuth = response.vertical_azimuth;
                    for (let i = 0; i < positions.length; i++) {
                        let rl = '';
                        let horizontal_az = 0;
                        let vertical_az = 0;
                        let ch = '';
                        let rt_type;
                        if (topology[i].length > 0) {
                            rl = 'Ap' + rl;
                            console.log(rl)
                            horizontal_az = Math.ceil(horizontal_azimuth[i]);
                            console.log(horizontal_az);
                            vertical_az = Math.ceil(vertical_azimuth[i]);
                            console.log(vertical_az);
                            ch += channel_array[i][1].toString();
                            ch += " ";
                            rt_type = "StartMesh HD";
                            if (topology[i].length > 1){
                                rt_type = "Sector M90";
                                if (horizontal_az >= 90) {
                                    rt_type = "Sector D120";
                                }
                                const end1 = symmetricPoint(positions_map[connection_boundaries[i][0]], positions_map[i]);
                                const end2 = symmetricPoint(positions_map[connection_boundaries[i][1]], positions_map[i]);
                                const triangleCoords = [
                                    positions_map[i], 
                                    end1, 
                                    end2
                                ];
                                const color = channel_colors[channel_array[i][1]];
                                const triangle = new google.maps.Polygon({
                                    paths: triangleCoords,
                                    strokeColor: color,
                                    strokeOpacity: 0.8,
                                    strokeWeight: 2,
                                    fillColor: color,
                                    fillOpacity: 0.35,
                                    clickable: false    
                                });
                                triangle.setMap(map);
                                triangles.push(triangle);
                            }
                        }
                        if (i>= sz_src && connections[i]!== -1) {
                            rt_type = "StartMesh HD";
                            rl += ' Client';
                            ch += channel_array[i][0].toString();
                            const startCoords = positions_map[i];
                            const endCoords   = positions_map[connections[i]];
                            const rate        = Math.ceil(rates[i]);
                            const consumed_rate = Math.ceil(consumed_rates[i]);
                            const cap  = Math.ceil(capacities[i][connections[i]]);
                            const dist = distances[i][connections[i]] ;
                            const center = positions_map[connections[i]];
                            const radius = distances[i][connections[i]];
                            const path = [startCoords, endCoords];
                            const channel = channel_array[i][0]
                            let Data = [];
                            
                            const line = new google.maps.Polyline({
                                path: [startCoords, endCoords],
                                geodesic: true,
                                strokeColor: '#000000',
                                strokeOpacity: 1.0,
                                strokeWeight: 2,
                                icons: [{
                                    icon: {
                                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW
                                    },
                                    offset: '100%'
                                }],
                                map: map
                            });
                            
                            // Adding click event listener to the line
                            google.maps.event.addListener(line, 'click', function(e) {
                                const elevationData = path_elevations[i][connections[i]];
                                const labels = Array.from({ length:samples}, (_, k) => Math.floor((dist / (samples -1) * k )));
                                const initial_height = positions[i][2];
                                const last_height    = positions[connections[i]][2];  
                                const pathData = Array.from({ length:samples}, (_, k) => (((last_height - initial_height)/ (samples -1  )) * k + initial_height ));
                                const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples-1) * k ) * (dist -(dist / (samples-1) * k )) * 0.06/ dist))))); 
                                const contentString = `
                                    <div>
                                        <br><b>Link informations:</b></br>
                                        <br>Capacity: ${cap} Mbps</br>
                                        <br>Distance: ${dist} Km</br>
                                        <br>Current rate: ${rate} Mbps</br>
                                        <br>Channel: ${channel} </br>
                                        
                                    </div>
                                `;
                                showLineInfo(contentString, elevationData,fresnelData, pathData,labels);
                            });
                            line.setMap(map);
                            lines.push(line);
                            
                        }
                        if (connections[i]=== -1 && topology[i].length ==0){
                            rl = '-';
                            horizontal_az = 0;
                            vertical_az = 0;
                            ch = 0;
                            rt_type = '-';
                        }
                        roles.push(rl);
                        horizontal_azimuths.push(horizontal_az)
                        vertical_azimuths.push(vertical_az)
                        channel_links.push(ch);
                        router_type.push(rt_type);

                    }
                    document.querySelector('.antenna_characteristics').style.display = 'block';
                    //document.querySelector('.download_button').style.display = 'block';
                    
                }
                else {  
                        alert('Cannot create topology with this configuration. Please try another config!');
                        show_topology_error();
                }  
            })
            .catch(error => {
                alert('Another error while being unable to create topology with this configuration. Please try another config!');
                
            });
        }

        function show_topology_error() {
            document.querySelector('.antenna_characteristics').style.display = 'block';
            for (let i = 0; i < total_sz; i++) {
                for (let j of connections[i]) {  // Iterating over the elements of connections[i]
                    const dist = distances[i][j];
                    const startCoords = positions_map[i];
                    const endCoords = positions_map[j];  // 'j' directly represents the connected node
                    const path = [startCoords, endCoords];
        
                    const line = new google.maps.Polyline({
                        path: path,  // Simplified this to use the 'path' variable directly
                        geodesic: true,
                        strokeColor: '#000000',
                        strokeOpacity: 1.0,
                        strokeWeight: 2,
                        map: map
                    });
        
                    google.maps.event.addListener(line, 'click', function(e) {
                        const elevationData = path_elevations[i][j];  // Access elevation data correctly
                        const labels = Array.from({ length: samples }, (_, k) => Math.floor((dist / (samples - 1) * k)));
        
                        const initial_height = positions[i];
                        const last_height    = positions[connections[i]];  
                        const pathData = Array.from({ length: samples }, (_, k) => 
                            ((last_height - initial_height) / (samples - 1)) * k + initial_height
                        );
                        const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples-1) * k ) * (dist -(dist / (samples-1) * k )) * 0.06/ dist))))); 
                        const contentString = `
                            <div>
                                <br>Distance: ${dist} Km</br>
                            </div>
                        `;
                        showLineInfo(contentString, elevationData,fresnelData, pathData, labels);
                    });
                    lines.push(line);
                }
            }
        }

        // Function to show line information and elevation chart
        function showLineInfo(contentString, elevationData,fresnelData,pathData, labels) {
            document.getElementById('line-info').style.display = 'flex'; 
            console.log("showing line information")
            const lineInfo = document.getElementById('line-information');
            lineInfo.innerHTML = contentString;
            plot(elevationData,fresnelData,pathData,labels);
        }

        // Function to plot elevation data
        function plot(elevationData,fresnelData,pathData,labels) {
            const ctx = document.getElementById('elevation-chart').getContext('2d');
            if (chartInstance){
                chartInstance.destroy();
            }
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Elevation',
                            data: elevationData,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)', // Light fill color under the curve
                            borderWidth: 1,
                            fill: true, // Fills the area under the curve
                            tension: 0.4 // Adds some smoothing to the line
                        },
                        {
                            label: 'Fresnel Zone',
                            data: fresnelData,
                            borderColor:'rgba(255, 255, 0, 1)',
                            borderWidth: 1,
                            fill: false // This will just plot a line, no fill
                        },
                        {
                            label: 'Path',
                            data: pathData,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            fill: false // This will just plot a line, no fill
                        }
                    ]
                },
                options: {
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Distance(km)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Elevation (m)'
                            }
                        }
                    }
                }
            });
        }

        function addLinesToXML(existingXML, lines) {
            console.log(xmlDoc);
            const kmlNS = "http://www.opengis.net/kml/2.2";
            
            // Find or create the Document element
            let documentElement = xmlDoc.getElementsByTagNameNS(kmlNS, "Document")[0];

            // Add new lines
            lines.forEach(line => {
                const startCoords = line.getPath().getAt(0);
                const endCoords = line.getPath().getAt(1);

                // Create Placemark for each line
                const placemark = xmlDoc.createElementNS(kmlNS, "Placemark");
                placemark.innerHTML = `
                    <name>Line with Arrow</name>
                    <styleUrl>#arrowStyle</styleUrl>
                    <LineString>
                        <coordinates>${startCoords.lng()},${startCoords.lat()},0 ${endCoords.lng()},${endCoords.lat()},0</coordinates>
                    </LineString>
                `;
                documentElement.appendChild(placemark);
            });
        
            // Serialize the XML document to string
            const serializer = new XMLSerializer();
            const updatedXML = serializer.serializeToString(xmlDoc);
        
            return updatedXML;
        }

        function downloadUpdatedKML(updatedXML) {
            const blob = new Blob([updatedXML], { type: 'application/vnd.google-earth.kml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'updated_map.kml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up after download
        }

        function updateAndDownloadKML(lines) {
            // Assume xmlContent is the existing KML XML content
            const updatedXML = addLinesToXML(xmlContent, lines);
            downloadUpdatedKML(updatedXML);
        }

        document.getElementById('download_button').addEventListener('click', function() {
            updateAndDownloadKML(lines);
        });

        function saveToLocalStorage() {
            const marker_index_array = Array.from(marker_index.entries());
            const lines_array = lines.map(line => ({
                path: line.getPath().getArray().map(latlng => ({ lat: latlng.lat(), lng: latlng.lng() })),  // Extract path as an array of lat/lng objects
                strokeColor: line.strokeColor,
                strokeOpacity: line.strokeOpacity,
                strokeWeight: line.strokeWeight
            }));
            globalVariables = {
                marker_index: marker_index_array,
                lines:lines_array,
                path_elevations,
                final_connections,
                distances,
                positions,
                positions_map,
                path_elevations,
                final_connections,
                distances,
                total_labels,
                sz_src,
                obligatory_nodes,
                node_capacities,
                marker_names,
                horizontal_azimuths,
                vertical_azimuths,
                roles,
                horizontal_azimuths,
                vertical_azimuths,
                router_type,
                channel_links,
            };
            localStorage.setItem('globalVariables', JSON.stringify(globalVariables));
            alert('Variables saved to local storage.');
        }

        function importFromFile(event) {
            const appGlobals = {};
            const file = event.target.files[0];
            if (!file) return;
            document.querySelector(".upload_json_file").style.display="None";
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    console.log(importedData);
                    if (typeof importedData.sz_src === 'number') {
                        sz_src = importedData.sz_src;
                        console.log('sz_src:', sz_src);
                    } else {
                        throw new Error('Invalid format for sz_src');
                    }
                    // Handle other data as needed
                    for (const [key, value] of Object.entries(importedData)) {
                        // Check if the key is not one of the predefined ones
                        if (!['positions', 'sz_src', 'positions_map', 'marker_index', 'distances', 'final_connections', 'lines', 'path_elevations'].includes(key)) {
                            // Check if value is an array
                            if (Array.isArray(value)) {
                                appGlobals[key] = value;  // Assign array variables to the namespace object
                            } else {
                                console.warn(`Skipping ${key}: Not an array or invalid type`);
                            }
                        }
                    }
                    // Log the namespace object to verify contents
                    console.log(appGlobals);
                    if (importedData.marker_index) {
                        if (Array.isArray(importedData.marker_index)) {
                            // Convert the array of arrays to a Map
                            marker_index = new Map(importedData.marker_index);
                            console.log('marker_index:', marker_index); // Check if the map is populated
                        } else {
                            throw new Error('Invalid format for marker_index');
                        }
                    }
                    if (importedData.positions) {
                        if (Array.isArray(importedData.positions) &&
                            importedData.positions.every(row => Array.isArray(row))) {
                            positions = importedData.positions;
                        } else {
                            throw new Error('Invalid format for positions');
                        }
                    }

                    if (importedData.positions_map) {
                        if (Array.isArray(importedData.positions_map)) {
                            // Map the data if necessary (though it's already in the expected format)
                            positions_map = importedData.positions_map.map(item => ({
                                lat: item.lat,
                                lng: item.lng
                            }));
                        } else {
                            throw new Error('Invalid format for positions_map');
                        }
                    }

                    // Handle distances
                    if (importedData.distances) {
                        if (Array.isArray(importedData.distances) &&
                            importedData.distances.every(row => Array.isArray(row))) {
                            distances = importedData.distances;
                        } else {
                            throw new Error('Invalid format for distances');
                        }
                    }
        
                    // Handle final_connections
                    if (importedData.final_connections) {
                        if (Array.isArray(importedData.final_connections) &&
                            importedData.final_connections.every(row => Array.isArray(row))) {
                            final_connections = importedData.final_connections;
                        } else {
                            throw new Error('Invalid format for final_connections');
                        }
                    }

                    if (importedData.path_elevations) {
                        if (Array.isArray(importedData.path_elevations) &&
                            importedData.path_elevations.every(row => Array.isArray(row))) {
                            path_elevations = importedData.path_elevations;
                        } else {
                            throw new Error('Invalid format for path_elevations');
                        }
                    }

                    
                    // Handle lines (polylines)
                    if (importedData.lines) {
                        if (Array.isArray(importedData.lines)) {
                            // Clear existing lines
                            lines.forEach(line => line.setMap(null));
                            lines = [];
                    
                            // Add imported lines to the map
                            importedData.lines.forEach(lineData => {
                                const path = lineData.path.map(point => new google.maps.LatLng(point.lat, point.lng));
                                const polyline = new google.maps.Polyline({
                                    path: path,
                                    strokeColor: lineData.strokeColor,
                                    strokeOpacity: lineData.strokeOpacity,
                                    strokeWeight: lineData.strokeWeight,
                                    map: map // Assuming `map` is the Google Maps instance
                                });
                    
                                google.maps.event.addListener(polyline, 'click', function(e) {
                                    // Ensure startPoint and endPoint are properly initialized
                                        const startPoint = path[0];  // First point in the path
                                        const endPoint = path[path.length - 1]; // Last point in the path
                                        // Convert points to string to match keys in marker_index
                                        const startKey = `${startPoint.lat()},${startPoint.lng()}`;
                                        const endKey = `${endPoint.lat()},${endPoint.lng()}`;
                    
                                        // Initialize elevationData, dist, etc.
                                        const start_index = marker_index.get(startKey);
                                        const end_index   = marker_index.get(endKey);
                    
                                        if (start_index !== undefined && end_index !== undefined) {
                                            const elevationData = path_elevations[start_index][end_index]; // Ensure path_elevations is correctly defined
                                            const dist = distances[start_index][end_index]; // Ensure distances is correctly defined
                                            const labels = Array.from({ length: samples }, (_, k) => Math.floor((dist / (samples - 1) * k)));
                                            const initial_height = positions[start_index][2]; // Ensure positions is correctly defined
                                            const last_height = positions[end_index][2];
                                            const pathData = Array.from({ length: samples }, (_, k) => (((last_height - initial_height) / (samples - 1)) * k + initial_height));
                                            const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples - 1) * k) * (dist - (dist / (samples - 1) * k)) * 0.06 / dist)))));
                    
                                            const contentString = `
                                                <div>
                                                    <br><b>Link information:</b></br>
                                                    <br>Distance: ${dist} Km</br>
                                                </div>
                                            `;
                                            showLineInfo(contentString, elevationData, fresnelData, pathData, labels);
                                        } else {
                                            console.warn('Start or end index is undefined in marker_index');
                                        }
                                    
                                });
                    
                                lines.push(polyline);
                            });
                        } else {
                            throw new Error('Invalid format for lines');
                        }
                    }
                    // Handle layers and their markers
                    
                    
                    total_labels = appGlobals.total_labels;
                    node_capacities = appGlobals.node_capacities;
                    obligatory_nodes = appGlobals.obligatory_nodes;
                    marker_names = appGlobals.marker_names,
                    horizontal_azimuths = appGlobals.horizontal_azimuths;
                    vertical_azimuths  = appGlobals.vertical_azimuths;
                    roles   = appGlobals.roles,
                    router_type = appGlobals.router_type,
                    channel_links = appGlobals.channel_links
                    
                    alert('Variables and data imported successfully');
                } catch (error) {
                    console.error('Error parsing JSON or importing variables:', error);
                    alert('Failed to import variables. Please check the file format.');
                }
            };
            reader.readAsText(file);
        }
        let map = new google.maps.Map(document.getElementById("map-container"), {
            zoom: 6,
            center: position,
            mapTypeId: "roadmap", 
        });
        elevator = new google.maps.ElevationService();
        drawingManager = new google.maps.drawing.DrawingManager({
            drawingMode: google.maps.drawing.OverlayType.POLYLINE,
            drawingControl: false,
            polylineOptions: {
            strokeColor: '#ff0000',
            strokeWeight: 2,
            },
        });
        const controlDiv = document.createElement('div');
        const controlUI  = document.createElement('div');
        controlUI.classList.add('custom-map-control-button');
        controlUI.title     = 'Click to draw a line';
        controlUI.innerHTML = 'Draw Line';
        controlUI.addEventListener('click', () => {
            drawingModeEnabled = !drawingModeEnabled;
            controlUI.innerHTML = drawingModeEnabled ? 'Exit Draw Mode' : 'Draw Line';
        });
        controlDiv.appendChild(controlUI);
        controlDiv.index = 1;
        map.controls[google.maps.ControlPosition.TOP_CENTER].push(controlDiv);
        const slider = document.getElementById("distanceSlider");
        const output = document.getElementById("distanceValue");
        // Update the initial value
        output.textContent = slider.value;
        dist_thresh = output;
        // Update the value dynamically as the slider is moved
        slider.oninput = function() {
            output.textContent = this.value;
            dist_thresh = this.value;

        };
        document.getElementById('new_project').addEventListener('click', function () {
            document.querySelector('.upload_kml_file').style.display = 'block';
            document.querySelector('#layer-control').style.display = 'block';
            document.querySelector('.max_dist_threshold').style.display = 'block';
            document.querySelector('.other_buttons').style.display = 'block';
            document.querySelector('.topology-container').style.display = 'block';
            document.querySelector('.download_button').style.display = 'block';
            document.querySelector('.first-options').style.display = 'none';
        });
        document.getElementById('old_project').addEventListener('click', function () {
            new_project = false;
            document.querySelector('.upload_kml_file').style.display = 'block';
            document.querySelector('.upload_json_file').style.display = 'block';
            document.querySelector('.max_dist_threshold').style.display = 'block';
            document.querySelector('.other_buttons').style.display = 'block';
            document.querySelector('.topology-container').style.display = 'block';
            document.querySelector('.download_button').style.display = 'block';
            document.querySelector('.first-options').style.display = 'none';
        });


        document.getElementById('upload_file').addEventListener('click', function () {
            var fileInput = document.getElementById('file');
            var file = fileInput.files[0];
            if (!file) {
                alert('Please upload an XML file.');
                return;
            }
            if (file.name.endsWith('.kml')) {
                readXMLFile(file);
                document.querySelector('.upload_kml_file').style.display = 'none';
            } else {
                alert('Unsupported file type. Please upload an XML file.');
            }
            
        });

        document.getElementById('processLayers').addEventListener('click', async function () {
    
            // Retrieve the selected options from source and destination layers
            var selectedSourceLayers = Array.from(document.getElementById('sourceLayers').selectedOptions).map(option => option.value);
            var selectedDestLayers = Array.from(document.getElementById('destLayers').selectedOptions).map(option => option.value);
            const spinner = document.getElementById("loading-spinner");
            spinner.style.display = "block";

            var source_markers = [];
            var dest_markers = [];
            var source_labels = [];
            var dest_labels = [];
        
            // Populate source_markers and source_labels based on the selected source layers
            for (let i = 0; i < selectedSourceLayers.length; i++) {
                source_markers = source_markers.concat(layers[selectedSourceLayers[i]]);
                source_labels = source_labels.concat(Array(layers[selectedSourceLayers[i]].length).fill(selectedSourceLayers[i]));
            }
        
            // Populate dest_markers and dest_labels based on the selected destination layers
            for (let j = 0; j < selectedDestLayers.length; j++) {
                dest_markers = dest_markers.concat(layers[selectedDestLayers[j]]);
                dest_labels = dest_labels.concat(Array(layers[selectedDestLayers[j]].length).fill(selectedDestLayers[j]));
            }
        
            // Combine all labels into a single array
            total_labels = [...source_labels, ...dest_labels];
            // Create a map that holds arrays of positions for each label
            
            for (let i = 0; i < total_labels.length; ++i) {
                if (layers_positions[total_labels[i]] !== undefined && layers_positions[total_labels[i]].length !== 0) {
                    positions = positions.concat(layers_positions[total_labels[i]]);
                }
                delete layers_positions[total_labels[i]]; // Prevent duplication in subsequent iterations
                
                if (layers_positions_map[total_labels[i]] !== undefined && layers_positions_map[total_labels[i]].length !== 0) {
                    positions_map = positions_map.concat(layers_positions_map[total_labels[i]]);
                }
                delete layers_positions_map[total_labels[i]]; // Prevent duplication in subsequent iterations
                if (markers_name_per_layer[total_labels[i]] !== undefined && markers_name_per_layer[total_labels[i]].length !== 0) {
                    marker_names = marker_names.concat(markers_name_per_layer[total_labels[i]]);
                }
                delete markers_name_per_layer[total_labels[i]]; // Prevent duplication in subsequent iterations
            }
            
            console.log(positions);
            console.log(positions_map);
            console.log(marker_names);
            for (let i = 0 ; i < positions.length; ++i){
                const l1 = positions_map[i].lat;
                const l2 = positions_map[i].lng;
                const key = `${l1},${l2}`;
                marker_index.set(key, i);
            }
            console.log(marker_index)
            // Fill matrices and process connections
            await fill_matrices();
            console.log("Matrices filled, proceeding to compute possible links");
            spinner.style.display = "none";

        
            // Combine all markers into a single array and calculate possible links
            total_markers = [...source_markers, ...dest_markers];
            sz_src = source_markers.length;
            node_capacities = [];
            for (let i = 0; i < total_labels.length; ++i) {
                if (total_labels[i] === 'Internet Source') {
                    node_capacities.push(2000);
                } else if (total_labels[i] === 'RDA') {
                    node_capacities.push(1);
                } else if (total_labels[i] === 'SITEs') {
                    node_capacities.push(1);
                } else {
                    node_capacities.push(0);
                }
            }
            console.log(node_capacities);
            console.log("computing possible_connections")
            final_connections = await possible_links(sz_src);
            // Logging the selections and total connections
            console.log('Selected Source Layers:', selectedSourceLayers);
            console.log('Selected Destination Layers:', selectedDestLayers);
            console.log('Total Connections:', final_connections);
        });

        document.getElementById("submit_thresh").addEventListener('click', function(){
            connections = fill_connections();
        });

        document.getElementById('generate-topology').addEventListener('click', handleGenerateTopology);
        document.getElementById('close-line-info').addEventListener('click', function() {
            document.getElementById('line-info').style.display = 'none';
        });  
        document.getElementById('saveToLocalStorage').addEventListener('click', saveToLocalStorage);
        document.getElementById('exportToFile').addEventListener('click', exportToFile);
        document.getElementById('importButton').addEventListener('click', () => {
            document.getElementById('importFromFile').click();
        });
        document.getElementById('importFromFile').addEventListener('change', importFromFile);
    }

    document.getElementById('generate-characteristics').addEventListener('click', function() {
        // Display the modal
        document.getElementById('myModal').style.display = 'block';
        document.getElementById('myModal').offsetHeight;
    
        // Populate the table with antenna data (replace with your actual data source)
        var antennaData = [];
        for (var i = 0; i < positions.length; i++) {
            antennaData.push({
                "Node Id": i,
                "Name": marker_names[i],
                "Router Type": router_type[i],
                "Roles": roles[i],
                "Horizontal Azimuth": horizontal_azimuths[i] !== 0 ? horizontal_azimuths[i] : "-",
                "Vertical Azimuth": vertical_azimuths[i] !== 0 ? vertical_azimuths[i] : "-",
                "Channel": channel_links[i] !== 0 ? channel_links[i] : "-",
            });
        }
        console.log("Antenna Data:", antennaData); // Debugging: Check if data is populated
    
        var tableBody = document.getElementById('antennaTableBody');
        tableBody.innerHTML = ''; 
        console.log("Table body cleared"); // Debugging
    
        // Populate the table with antenna data
        antennaData.forEach(function(antenna) {
            var row = document.createElement('tr');
    
            var nodeIdCell = document.createElement('td');
            nodeIdCell.textContent = antenna['Node Id'];
            row.appendChild(nodeIdCell);

            var positionsCell = document.createElement('td');
            positionsCell.textContent = antenna['Name'];
            row.appendChild(positionsCell);

            var typeCell = document.createElement('td');
            typeCell.textContent = antenna['Router Type'];
            row.appendChild(typeCell);
    
            var roleCell = document.createElement('td');
            roleCell.textContent = antenna['Roles'];
            row.appendChild(roleCell);
    
            var horizontalAzCell = document.createElement('td');
            horizontalAzCell.textContent = antenna['Horizontal Azimuth'];
            row.appendChild(horizontalAzCell);
    
            var verticalAzCell = document.createElement('td');
            verticalAzCell.textContent = antenna['Vertical Azimuth'];
            row.appendChild(verticalAzCell);
    
            var channelCell = document.createElement('td');
            channelCell.textContent = antenna['Channel'];
            row.appendChild(channelCell);
    
            tableBody.appendChild(row);
            console.log("Appended row:", row); // Debugging
        });
    
        // Toggle the visibility of the table (optional)
        var table = document.getElementById('antennaTable');
        table.style.display = 'table';
        
    });

    // Close the modal when the user clicks on <span> (x)
    document.querySelector('.close').addEventListener('click', function() {
        document.getElementById('myModal').style.display = 'none';
    });
    
    // Close the modal if the user clicks outside of it
    window.addEventListener('click', function(event) {
        if (event.target === document.getElementById('myModal')) {
            document.getElementById('myModal').style.display = 'none';
        }
    });
    
</script>
</body>
</html>


