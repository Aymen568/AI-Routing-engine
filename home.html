<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ff4444">
    <title>Topology Dashboard</title>
    <link rel="stylesheet" href="css/home.css">
    <script src = "js/geoxml3.js" ></script>
    <script src = "https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
</head>
<body>
<!-- ======= Header ======= -->
<header id="header">
    <div class="d-flex flex-column">
        <aside id="left-sidebar">
            <div class="sidebar-content">
                <img src="media/luceor_logo.png" alt="Luceor Logo">
                <h2>Create Your Network Topology</h2>
                <div class = "first-options">
                    <button id="new_project">New project</button>
                    <button id="old_project">Import existing project</button>
                </div>
                <div class="upload_kml_file" style="display: none;" >
                    <form enctype="multipart/form-data">
                        <input id="file" name="file" type="file" />
                        <button  type="button" id="load_kml_file">Upload KML file</button>
                    </form>
                </div>

                <div class="upload_csv_file" style="display: none;">
                    <form enctype="multipart/form-data">
                        <input id="csv_file" name="file" type="file" accept=".csv" />
                        <button type="button" id="upload_csv_file">Upload CSV file</button>
                    </form>
                </div>


                <div class="upload_json_file" style="display: none;" >
                    <input type="file" id="importFromFile" accept=".json" />
                    <button id="importButton" >Upload Json File</button>
                </div>
                <div id="layer-controls"></div>
                <div class="dist_threshold" style="display: none;">
                    <label for="distanceSlider">Select Distance (km):</label>
                    <input type="range" id="distanceSlider" min="1" max="100" value="50" step="1">
                    <span id="distanceValue">50 km</span>
                </div>
                <div id="layer-control" style="display: none;">
                        <button type="button" id="processLayers">Process Layers</button>
                </div>
                <div class="topology-container" style="display: none;" >
                    <button type="button" id="generate-topology">Generate Topology</button>
                </div>
                <div class="customizenode" style="display: none;">
                    <button id="customize_heights">Change Node Height</button>
                    <div id="heightForm" style="display: none;">
                        <label for="currentHeight">Current Height:</label>
                        <span id="currentHeight"></span><br>
                        <label for="newHeight">New Height:</label>
                        <input type="number" id="newHeight" step="1"><br>
                        <button id="updateHeightButton">Update Height</button>
                    </div>
                </div>
                <div class="other_buttons" style="display: none;">
                    <button id="exportToFile" >Save and Export to File</button>
                </div>
                <div class="antenna_characteristics" style="display: none;">
                    <button type="button" id="generate-characteristics">Topology characteristics</button>
                </div>
                <div class="download_button"  style="display: none;">
                    <button type="button" id="download_button">Download Topology</button>
                </div>
            </div>
        </aside>
    </div>
    <section id="sensorContainer" class="flex-container">
        <div id="map-container" class="map-container">
            <script async defer src="https://maps.googleapis.com/maps/api/js?key=key&v=beta&libraries=drawing&callback=initMap"></script>
        </div>
        <div id="progress-wrapper" style="display:none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; width: 300px; background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.2); text-align: center;">
            <div id="loading-spinner" style="margin-bottom: 10px;">
                <div class="spinner"></div>
            </div>
            <div id="progress-bar-container" style="margin-bottom: 10px;">
                <div id="progress-bar" style="background-color: #4caf50; height: 20px; width: 0%;"></div>
            </div>
            <div id="progress-text">0%</div>
        </div>
        <div id="line-info" style="display: none;">
            <span id="line-information"></span> 
            <canvas id="elevation-chart"></canvas>
            <button id="close-line-info">âœ–</button>
        </div>
    </section>
</header>
<div id="myModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Antenna Parameters</h2>
        <table id="antennaTable">
            <thead>
                <tr>
                    <th>Node Id</th>
                    <th>Name</th>
                    <th>Router Type</th>
                    <th>Roles</th>
                    <th>horizontal Azimuth</th>
                    <th>Vertical Azimuth</th>
                </tr>
            </thead>
            <tbody id="antennaTableBody">
            </tbody>
        </table>
    </div>
</div>

<script>
    let map;
    let elevator;
    let drawingManager;
    let markers = [];
    let lines   = [];
    let positions = [];
    let antenna_heights= [];
    let positions_map = [];
    let desired_rates = [];
    let chartInstance;
    let generateTopologyClicked = false;
    let marker1 = null;
    let marker2 = null;
    let drawingModeEnabled = false;
    let colors = {};
    let roles = [];
    let horizontal_azimuths =[];
    let vertical_azimuths=[];
    let router_type =[];
    let upload  =false;
    let path_elevations = [];
    let distances       = [];
    let marker_index    =  new Map();
    let dist_thresh     = 0;
    let total_labels    = [];
    let samples         = 30;
    let final_connections = [];
    let sz_src;
    let obligatory_nodes = [];
    let node_capacities  = [];
    let total_markers    = [];
    let position_labels  = [];
    let layers_positions = {};
    let layers_positions_map ={}; 
    let markers_name_per_layer = {};
    let antenna_heights_per_layer = {};
    let marker_names = [];
    let layers           = {};
    let layerControls    = {};
    let xmlContent       = '';
    let xmlDoc;
    let globalVariable;
    let new_project = true;
    let marker2update = false;
    let hauteur_map = new Map();
    const position = { lat: 24.6986413, lng: 44.0534141 };
    async function initMap() {

        function processCSVFile() {
            const fileInput = document.getElementById('csv_file');
            const file = fileInput.files[0];
        
            // Ensure a file is selected
            if (!file) {
                alert('Please select a CSV file to upload.');
                return;
            }
        
            // Initialize hauteur_map if not already done
            if (typeof hauteur_map === 'undefined') {
                hauteur_map = new Map(); // Assuming `hauteur_map` is a global Map object
            }
        
            // Read and parse the CSV file
            const reader = new FileReader();
            reader.onload = function(e) {
                const csvData = e.target.result;
                console.log("CSV Data Loaded:", csvData); // Debug: Check the loaded CSV data
        
                // Parse CSV data using PapaParse
                Papa.parse(csvData, {
                    header: true,  // Treat the first row as headers
                    skipEmptyLines: true,
                    complete: function(results) {
                        console.log("Parsed CSV Results:", results.data); // Debug: Check parsed results
        
                        // Ensure results.data is an array
                        if (!Array.isArray(results.data)) {
                            console.error("Parsed data is not an array:", results.data);
                            return;
                        }
        
                        // Check if results.data is not empty
                        if (results.data.length === 0) {
                            console.log("No data found in CSV file.");
                            return;
                        }
        
                        // Loop through the parsed data
                        results.data.forEach((row, index) => {
                            console.log(`Processing row ${index + 1}:`, row);
        
                            // Extract and validate the values for Hauteur support, Latitude, and Longitude
                            let hauteurSupport = row["Hauteur support "].trim();
                             // Trim any extra whitespace
                            let latitude = parseFloat(row['Latitude']);
                            let longitude = parseFloat(row['Longitude']);
                            latitude = parseFloat(latitude.toFixed(5));
                            longitude = parseFloat(longitude.toFixed(5));
        
                            // Handle 'Hauteur support ' which can be an integer or '-'
                            if (hauteurSupport === '-') {
                                hauteurSupport = 10;  // Set to null if it is '-'
                            } else {
                                hauteurSupport =parseFloat(hauteurSupport, 10);
                                hauteurSupport = Math.floor(hauteurSupport);  
                                // Convert to integer
                                console.log(hauteurSupport)
                                if (isNaN(hauteurSupport)) hauteurSupport = null; // Handle invalid numbers
                            }
        
                            // Check if Latitude and Longitude are valid floats
                            if (!isNaN(latitude) && !isNaN(longitude)) {
                                console.log('Valid Latitude:', latitude, 'Longitude:', longitude);
                                // Update hauteur_map with parsed values
                                hauteur_map.set(`${latitude},${longitude}`, hauteurSupport);
                            } else {
                                console.log('Invalid Latitude or Longitude');
                            }
                        });
                    },
                    error: function(error) {
                        console.error("Error parsing CSV:", error);
                    }
                });
            };
        
            // Read the file as text
            reader.readAsText(file);
            document.querySelector('.upload_csv_file').style.display = 'none';
        }
        

        function handleMarkerClick(marker) {
            if (!marker1) {
                marker1 = marker;
            } else if (!marker2) {
                marker2 = marker;
                if (marker1.getPosition().lat != marker2.getPosition().lat  ||   marker1.getPosition().lng != marker2.getPosition().lng){
                    drawLineBetweenMarkers(marker1, marker2)
                }
                marker1 = null;
                marker2 = null;
            }
        }

        function select_marker2change_heights(marker) {
                const index = marker_index.get(`${marker.getPosition().lat()},${marker.getPosition().lng()}`);
                if (index !== undefined) {
                    // Display current height
                    displayCurrentHeight(index);
        
                    // Show the height form
                    showHeightForm(index);
                } else {
                    alert('Marker not found. Please enter valid coordinates.');
                }

        }

        function updateHeight(index) {
            const newHeight = parseInt(document.getElementById('newHeight').value, 10);
            if (!isNaN(newHeight)) {
                antenna_heights[index] = newHeight;  // Update the height
                alert(`Height updated to ${newHeight} for marker at index ${index}`);
                updatepossibleconnections(index);
                // Hide the height form after updating
                console.log(index);
                document.getElementById('heightForm').style.display = 'none';
            } else {
                alert('Please enter a valid number for the new height.');
            }
        }
        
        function updatepossibleconnections(index){
            let sz = positions.length;

            for (let j = 0; j < sz ; ++j) {
                if (j !== index){
                    // Find the start and end positions in the positions_map
                    let pathClear = true;
                    let dst = distances[j][index];
                    if (dst <= dist_thresh) {
                        const path_elevation = path_elevations[index][j];
                        const elevationStart = positions[index][2] + antenna_heights[index];
                        const elevationEnd = positions[j][2]+ antenna_heights[j];
                        const labels = Array.from({ length: path_elevation.length }, (_, k) => (dst / (samples-1) * k ));
                        for (let k = 1; k < path_elevation.length - 1; k++) {
                            let elevation = path_elevation[k];
                            let interpolatedElevation  = elevationStart + ((elevationEnd - elevationStart) * (k / (samples -1) ));
                            // TO ACTIVATE THE FRESNEL ZONE VERIFICATION
                            // interpolatedElevation -=  (17.32 * Math.sqrt(((dst / (samples-1) * k ) * (dst -(dist / (samples-1) * k ) * 0.06/ dst);
                            if (elevation >= interpolatedElevation) {
                                pathClear = false;
                                break;
                            }
                        }
                        let index1 = Math.min(index, j);
                        let index2 = Math.max(index, j);
                        if (pathClear){
                            console.log(final_connections[index].includes(j));
                            if (!final_connections[index1].includes(index2)) {
                                final_connections[index1].push(index2);
                            }
                        }
                        else{
                            if (final_connections[index1].includes(index2)) {
                                const index_occ = final_connections[index1].indexOf(index2);
                                if (index_occ > -1) {
                                    final_connections[index1].splice(index_occ, 1);
                                }
                            }
                        }
                    } 
                }
            }
        }
        
        // Function to display the current height of the marker
        function displayCurrentHeight(index) {
            document.getElementById('currentHeight').textContent = antenna_heights[index];
        }
        
        // Function to show the form to change the height
        function showHeightForm(index) {
            document.getElementById('heightForm').style.display = 'block';
        
            // Add event listener to update button
            document.getElementById('updateHeightButton').onclick = () => updateHeight(index);
        }
        

        function drawLineBetweenMarkers(marker1, marker2) {
            const path = [marker1.getPosition(), marker2.getPosition()];
            const line = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: '#ff0000',
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map,
            });
            lines.push(line); 
            google.maps.event.addListener(line, 'click', function() {
                plot_elevation_data(marker1,marker2);
            });
        }

        function plot_elevation_data(marker1, marker2){
            const start_index = marker_index.get(`${marker1.getPosition().lat()},${marker1.getPosition().lng()}`);
            const end_index   = marker_index.get(`${marker2.getPosition().lat()},${marker2.getPosition().lng()}`);
            console.log("start_index", start_index,"end_index", end_index);
            const dist  =  distances[start_index][end_index];
            const elevationData = path_elevations[start_index][end_index];
            const labels = Array.from({ length:samples}, (_, k) => Math.floor((dist / (samples-1) * k )));
            const initial_height = positions[start_index][2] + antenna_heights[start_index];
            const last_height    = positions[end_index][2] + antenna_heights[end_index];     
            const pathData = Array.from({ length:samples}, (_, k) => (((last_height - initial_height)/ (samples-1) ) * k + initial_height ));     
            const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples-1) * k ) * (dist -(dist / (samples-1) * k )) * 0.06/ dist))))); 
            showLineInfo(`distance :${dist} km`, elevationData,fresnelData,pathData,labels);
        }

        function readXMLFile(file) {
            var reader = new FileReader();
            reader.onload = function(e) {
                xmlContent = e.target.result;
                parseXML(xmlContent);
            };
            reader.readAsText(file);
        }

        
        async function parseXML(xmlContent) {
            const parser = new DOMParser();
            xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            console.log(xmlDoc);
            
            const folderColors = {
                'TOTEM-SA': 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
                'SITEs': 'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png',
                'RDA': 'http://maps.google.com/mapfiles/ms/icons/orange-dot.png',
                'Internet Source': 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png'
            };
            layers = {}; // Reset layers
            layers_positions_map = {}; // Reset layers_positions_map
            layers_positions = {}; // Reset layers_positions
            markers_name_per_layer = {};
            markers = []; // Reset markers array
        
            // Find all Folder elements
            const folders = xmlDoc.getElementsByTagName('Folder');
            console.log(`Found ${folders.length} folders`);
        
            // Process folders asynchronously
            for (const folder of folders) {
                const folderName = folder.getElementsByTagName('name')[0].textContent;
                const folderColor = folderColors[folderName];
                if (!layers[folderName]) {
                    layers[folderName] = [];
                    addLayerControls(folderName);
                    // Populate select options
                }
                const placemarks = folder.getElementsByTagName('Placemark');
                // Process placemarks asynchronously
                for (const placemark of placemarks) {
                    const name = placemark.getElementsByTagName('name')[0].textContent;
                    const coordinates = placemark.getElementsByTagName('coordinates')[0].textContent.trim().split(',');
                    const latitude = parseFloat(coordinates[1]);
                    const longitude = parseFloat(coordinates[0]);
                    const maxHeightElement = placemark.querySelector('SimpleData[name="Maximum Height (m)"]');
                    var antenna_height = maxHeightElement ? parseFloat(maxHeightElement.textContent) : 10;
                    if (folderName === 'RDA') {
                        antenna_height = 20;
                    }
                    if (new_project){
                        var elevation = await getElevation({ lat: latitude, lng: longitude });
                        if (!layers_positions_map[folderName]) {
                            layers_positions_map[folderName] = [];
                        }
                        if (!markers_name_per_layer[folderName]) {
                            markers_name_per_layer[folderName] = [];
                        }
                        if (!layers_positions[folderName]) {
                            layers_positions[folderName] = [];
                        }
                        if (!antenna_heights_per_layer[folderName]) {
                            antenna_heights_per_layer[folderName] = [];
                        }
                        layers_positions_map[folderName].push({ lat: latitude, lng: longitude });
                        layers_positions[folderName].push([latitude, longitude, elevation]);
                        markers_name_per_layer[folderName].push(name);
                        antenna_heights_per_layer[folderName].push(antenna_height);
                    }
                    const marker = new google.maps.Marker({
                        position: { lat: latitude, lng: longitude },
                        map: null, // Map will be added later
                        title: name,
                        icon: {
                            url: folderColor,
                            scaledSize: new google.maps.Size(40, 40)
                        }
                    });
                    layers[folderName].push(marker);
                    marker.addListener('click', function() {
                        if (drawingModeEnabled) {
                            handleMarkerClick(marker);
                        } 
                        if (marker2update){
                            select_marker2change_heights(marker);
                            marker2update = false;
                        }
                    });
                    markers.push(marker);
                }
            }
            console.log(layers);
            console.log(layers["TOTEM-SA"]);
        }

        function addLayerControls(folderName) {
            var controlContainer = document.createElement('div');
            var control = document.createElement('input');
            control.type = 'checkbox';
            control.id = folderName;
            control.checked = false; 
            control.addEventListener('change', function() {
                updateLayerVisibility(folderName, this.checked);
            });
            var label = document.createElement('label');
            label.htmlFor = folderName;
            label.appendChild(document.createTextNode(folderName));
            // Append the control and label to the container
            controlContainer.appendChild(control);
            controlContainer.appendChild(label);
            // Append the container to the main layer controls container
            var container = document.getElementById('layer-controls'); // Assuming you have a container for controls
            container.appendChild(controlContainer);
            layerControls[folderName] = control;
        }
        
        function updateLayerVisibility(folderName, isVisible) {
            if (layers[folderName]) {
                layers[folderName].forEach(function(marker) {
                    marker.setMap(isVisible ? map : null); // Show or hide the marker based on layer visibility
                });
            }
        }

        function isLayerVisible(folderName) {
            return layerControls[folderName] && layerControls[folderName].checked;
        }

        async function getElevation(loc) {
            console.log(loc);
            try {
                const { results } = await elevator.getElevationForLocations({
                    locations: [loc],
                });
        
                if (results[0]) {
                    const elevation = results[0].elevation;
                    console.log("elevation", elevation);
                    return elevation;
                } else {
                    console.log("Can't get the elevation for this point");
                    return 0; // Return 0 in case of an error
                }
            } catch (error) {
                console.error('Elevation request failed', error);
                return 0; // Return 0 in case of an error
            }
        }
        
        function possible_links(sz_src) {
            let sz1 = positions.length;
            let total_connections = Array.from({ length: sz1 }, () => []); // Initialize with empty arrays
            for (let i = 0; i < sz1; ++i) {
                    if (total_labels[i] === 'SITEs'  || total_labels[i] === 'RDA'){
                        obligatory_nodes.push(i);
                    }
                for (let j = Math.max(i + 1, sz_src); j < sz1; ++j) {
                    // Find the start and end positions in the positions_map
                    let pathClear = true;
                    let dst = distances[i][j];
                    if (dst <= dist_thresh) {
                        const path_elevation = path_elevations[i][j];
                        const elevationStart = positions[i][2] + antenna_heights[i];
                        const elevationEnd = positions[j][2]+ antenna_heights[j];
                        const labels = Array.from({ length: path_elevation.length }, (_, k) => (dst / (samples-1) * k ));
                        for (let k = 1; k < path_elevation.length - 1; k++) {
                            let elevation = path_elevation[k];
                            let interpolatedElevation  = elevationStart + ((elevationEnd - elevationStart) * (k / (samples -1) ));
                            // TO ACTIVATE THE FRESNEL ZONE VERIFICATION
                            // interpolatedElevation -=  (17.32 * Math.sqrt(((dst / (samples-1) * k ) * (dst -(dist / (samples-1) * k ) * 0.06/ dst);
                            if (elevation >= interpolatedElevation) {
                                pathClear = false;
                                break;
                            }
                        }
                        if (pathClear) {
                            total_connections[i].push(j);
                        }
                    } 
                }
            }
            console.log(total_connections);
            return total_connections;
        }

        async function fill_matrices() {
            try {
                // Define the API endpoint
                const apiEndpoint = 'http://127.0.0.1:3000/fill-matrices';
                // Make the POST request to the Flask API
                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        positions_map: positions_map,
                        threshold :dist_thresh,
                        samples: samples,
                    }),
                });
                // Check if the response is ok (status code 200-299)
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                // Parse the JSON response
                const data = await response.json();
                // Extract distances and path elevations from the response
                distances = data.distances;
                path_elevations = data.path_elevations;
                // Handle the API response
                console.log('Distances:', distances);
                console.log('Path Elevations:', path_elevations);
            } catch (error) {
                // Handle errors
                console.error('Error calling Flask API:', error);
                distances = [];
                path_elevations =  [];
            }
        }
        

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function symmetricPoint(center, point) {
            return {
                lat: 2 * center.lat - point.lat,
                lng: 2 * center.lng - point.lng
            };
        }

        
        async function handleGenerateTopology(event) {
             // Clear all lines from the map
             for (let line of lines) {
                line.setMap(null);
            }
            lines = [];
            roles = [];
            horizontal_azimuths= [];
            vertical_azimuths = []
            const formData = {
                "n": sz_src,
                "positions": positions,
                "labels": total_labels,
                "distances": distances,
                "obligatory_nodes": obligatory_nodes,
                "possible_connections": final_connections
            };
            console.log(formData);
            await fetch('http://localhost:5000/generate_topology', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(formData),
            })
            .then(response => {
                if (!response.ok) {
                        throw new Error(`Server returned status: ${response.status}`);
                }
                return response.json();
            })
            .then( async response => {
                
                if (response.state ){
                    roles= []
                    horizontal_azimuths = [];
                    vertical_azimuths = [];
                    router_type = [];
                    generateTopologyClicked = true;
                    const topology = response.node_tree;
                    const connections = response.node_list;
                    const connection_boundaries = response.connection_boundaries;
                    const horizontal_azimuth = response.horizontal_azimuth;
                    const vertical_azimuth = response.vertical_azimuth;
                    for (let i = 0; i < positions.length; i++) {
                        let rl = '';
                        let horizontal_az = 0;
                        let vertical_az = 0;
                        let rt_type;
                        if (topology[i].length > 0) {
                            rl = 'Ap' + rl;
                            console.log(rl)
                            horizontal_az = Math.ceil(horizontal_azimuth[i]);
                            console.log(horizontal_az);
                            vertical_az = Math.ceil(vertical_azimuth[i]);
                            console.log(vertical_az);
                            rt_type = "StartMesh HD";
                            if (topology[i].length > 1){
                                rt_type = "Sector M90";
                                if (horizontal_az >= 90) {
                                    rt_type = "Sector D120";
                                }
                            }
                        }
                        if (i>= sz_src && connections[i]!== -1) {
                            rt_type = "StartMesh HD";
                            rl += ' Client';
    
                            const startCoords = positions_map[i];
                            const endCoords   = positions_map[connections[i]];
                            const dist = distances[i][connections[i]] ;
                            const center = positions_map[connections[i]];
                            const radius = distances[i][connections[i]];
                            const path = [startCoords, endCoords];
                            let Data = [];
                            
                            const line = new google.maps.Polyline({
                                path: [startCoords, endCoords],
                                geodesic: true,
                                strokeColor: '#000000',
                                strokeOpacity: 1.0,
                                strokeWeight: 2,
                                icons: [{
                                    icon: {
                                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW
                                    },
                                    offset: '100%'
                                }],
                                map: map
                            });
                            
                            // Adding click event listener to the line
                            google.maps.event.addListener(line, 'click', function(e) {
                                const elevationData = path_elevations[i][connections[i]];
                                const labels = Array.from({ length:samples}, (_, k) => Math.floor((dist / (samples -1) * k )));
                                const initial_height = positions[i][2] + antenna_heights[i];
                                const last_height    = positions[connections[i]][2] + antenna_heights[connections[i]];  
                                const pathData = Array.from({ length:samples}, (_, k) => (((last_height - initial_height)/ (samples -1  )) * k + initial_height ));
                                const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples-1) * k ) * (dist -(dist / (samples-1) * k )) * 0.06/ dist))))); 
                                const contentString = `
                                    <div>
                                        <br><b>Link informations:</b></br>
                                        <br>Distance: ${dist} Km</br>
                                    </div>
                                `;
                                showLineInfo(contentString, elevationData,fresnelData, pathData,labels);
                            });
                            line.setMap(map);
                            lines.push(line);
                            
                        }
                        if (connections[i]=== -1 && topology[i].length ==0){
                            rl = '-';
                            horizontal_az = 0;
                            vertical_az = 0;
                            rt_type = '-';
                        }
                        roles.push(rl);
                        horizontal_azimuths.push(horizontal_az)
                        vertical_azimuths.push(vertical_az);
                        router_type.push(rt_type);

                    }
                    document.querySelector('.antenna_characteristics').style.display = 'block';
                    //document.querySelector('.download_button').style.display = 'block';
                    
                }
                else {  
                        alert('Cannot create topology with this configuration. Please try another config!');
                        show_topology_error();
                }  
            })
            .catch(error => {
                alert('Another error while being unable to create topology with this configuration. Please try another config!');
                
            });
        }

        function show_topology_error() {
            document.querySelector('.antenna_characteristics').style.display = 'block';
            for (let i = 0; i < total_sz; i++) {
                for (let j of final_connections[i]) {  // Iterating over the elements of connections[i]
                    const dist = distances[i][j];
                    const startCoords = positions_map[i];
                    const endCoords = positions_map[j];  // 'j' directly represents the connected node
                    const path = [startCoords, endCoords];
        
                    const line = new google.maps.Polyline({
                        path: path,  // Simplified this to use the 'path' variable directly
                        geodesic: true,
                        strokeColor: '#000000',
                        strokeOpacity: 1.0,
                        strokeWeight: 2,
                        map: map
                    });
        
                    google.maps.event.addListener(line, 'click', function(e) {
                        const elevationData = path_elevations[i][j];  // Access elevation data correctly
                        const labels = Array.from({ length: samples }, (_, k) => Math.floor((dist / (samples - 1) * k)));
        
                        const initial_height = positions[i] + antenna_heights[i];
                        const last_height    = positions[connections[i]] + antenna_heights[j];  
                        const pathData = Array.from({ length: samples }, (_, k) => 
                            ((last_height - initial_height) / (samples - 1)) * k + initial_height
                        );
                        const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples-1) * k ) * (dist -(dist / (samples-1) * k )) * 0.06/ dist))))); 
                        const contentString = `
                            <div>
                                <br>Distance: ${dist} Km</br>
                            </div>
                        `;
                        showLineInfo(contentString, elevationData,fresnelData, pathData, labels);
                    });
                    lines.push(line);
                }
            }
        }

        // Function to show line information and elevation chart
        function showLineInfo(contentString, elevationData,fresnelData,pathData, labels) {
            document.getElementById('line-info').style.display = 'flex'; 
            console.log("showing line information")
            const lineInfo = document.getElementById('line-information');
            lineInfo.innerHTML = contentString;
            plot(elevationData,fresnelData,pathData,labels);
        }

        // Function to plot elevation data
        function plot(elevationData,fresnelData,pathData,labels) {
            const ctx = document.getElementById('elevation-chart').getContext('2d');
            if (chartInstance){
                chartInstance.destroy();
            }
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Elevation',
                            data: elevationData,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)', // Light fill color under the curve
                            borderWidth: 1,
                            fill: true, // Fills the area under the curve
                            tension: 0.4 // Adds some smoothing to the line
                        },
                        {
                            label: 'Fresnel Zone',
                            data: fresnelData,
                            borderColor:'rgba(255, 255, 0, 1)',
                            borderWidth: 1,
                            fill: false // This will just plot a line, no fill
                        },
                        {
                            label: 'Path',
                            data: pathData,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            fill: false // This will just plot a line, no fill
                        }
                    ]
                },
                options: {
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Distance(km)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Elevation (m)'
                            }
                        }
                    }
                }
            });
        }

        function addLinesToXML(existingXML, lines) {
            console.log(xmlDoc);
            const kmlNS = "http://www.opengis.net/kml/2.2";
            
            // Find or create the Document element
            let documentElement = xmlDoc.getElementsByTagNameNS(kmlNS, "Document")[0];

            // Add new lines
            lines.forEach(line => {
                const startCoords = line.getPath().getAt(0);
                const endCoords = line.getPath().getAt(1);

                // Create Placemark for each line
                const placemark = xmlDoc.createElementNS(kmlNS, "Placemark");
                placemark.innerHTML = `
                    <name>Line with Arrow</name>
                    <styleUrl>#arrowStyle</styleUrl>
                    <LineString>
                        <coordinates>${startCoords.lng()},${startCoords.lat()},0 ${endCoords.lng()},${endCoords.lat()},0</coordinates>
                    </LineString>
                `;
                documentElement.appendChild(placemark);
            });
        
            // Serialize the XML document to string
            const serializer = new XMLSerializer();
            const updatedXML = serializer.serializeToString(xmlDoc);
        
            return updatedXML;
        }

        function downloadUpdatedKML(updatedXML) {
            const blob = new Blob([updatedXML], { type: 'application/vnd.google-earth.kml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'updated_map.kml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up after download
        }

        function updateAndDownloadKML(lines) {
            // Assume xmlContent is the existing KML XML content
            const updatedXML = addLinesToXML(xmlContent, lines);
            downloadUpdatedKML(updatedXML);
        }

        document.getElementById('download_button').addEventListener('click', function() {
            updateAndDownloadKML(lines);
        });

        function save_and_export() {
            const marker_index_array = Array.from(marker_index.entries());
            const lines_array = lines.map(line => ({
                path: line.getPath().getArray().map(latlng => ({ lat: latlng.lat(), lng: latlng.lng() })),  // Extract path as an array of lat/lng objects
                strokeColor: line.strokeColor,
                strokeOpacity: line.strokeOpacity,
                strokeWeight: line.strokeWeight
            }));
            globalVariables = {
                marker_index: marker_index_array,
                lines:lines_array,
                path_elevations,
                final_connections,
                distances,
                positions,
                positions_map,
                antenna_heights,
                path_elevations,
                final_connections,
                distances,
                total_labels,
                sz_src,
                obligatory_nodes,
                marker_names,
            };
            // Convert the object to a JSON string
            const jsonString = JSON.stringify(globalVariables, null, 2);  // Pretty print JSON with indentation

            // Create a Blob from the JSON string
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Create a link element to download the Blob
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'exported_data.json';  // Set the download filename

            // Append the link to the body and click it to start the download
            document.body.appendChild(link);
            link.click();

            // Remove the link after the download
            document.body.removeChild(link);
        }
            
        

        function importFromFile(event) {
            const appGlobals = {};
            const file = event.target.files[0];
            if (!file) return;
            document.querySelector(".upload_json_file").style.display="None";
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    console.log(importedData);
                    if (typeof importedData.sz_src === 'number') {
                        sz_src = importedData.sz_src;
                        console.log('sz_src:', sz_src);
                    } else {
                        throw new Error('Invalid format for sz_src');
                    }
                    // Handle other data as needed
                    for (const [key, value] of Object.entries(importedData)) {
                        // Check if the key is not one of the predefined ones
                        if (!['positions', 'sz_src', 'positions_map', 'marker_index', 'distances', 'final_connections', 'lines', 'path_elevations'].includes(key)) {
                            // Check if value is an array
                            if (Array.isArray(value)) {
                                appGlobals[key] = value;  // Assign array variables to the namespace object
                            } else {
                                console.warn(`Skipping ${key}: Not an array or invalid type`);
                            }
                        }
                    }
                    // Log the namespace object to verify contents
                    console.log(appGlobals);
                    if (importedData.marker_index) {
                        if (Array.isArray(importedData.marker_index)) {
                            // Convert the array of arrays to a Map
                            marker_index = new Map(importedData.marker_index);
                            console.log('marker_index:', marker_index); // Check if the map is populated
                        } else {
                            throw new Error('Invalid format for marker_index');
                        }
                    }
                    if (importedData.positions) {
                        if (Array.isArray(importedData.positions) &&
                            importedData.positions.every(row => Array.isArray(row))) {
                            positions = importedData.positions;
                        } else {
                            throw new Error('Invalid format for positions');
                        }
                    }

                    if (importedData.positions_map) {
                        if (Array.isArray(importedData.positions_map)) {
                            // Map the data if necessary (though it's already in the expected format)
                            positions_map = importedData.positions_map.map(item => ({
                                lat: item.lat,
                                lng: item.lng
                            }));
                        } else {
                            throw new Error('Invalid format for positions_map');
                        }
                    }

                    // Handle distances
                    if (importedData.distances) {
                        if (Array.isArray(importedData.distances) &&
                            importedData.distances.every(row => Array.isArray(row))) {
                            distances = importedData.distances;
                        } else {
                            throw new Error('Invalid format for distances');
                        }
                    }
        
                    // Handle final_connections
                    if (importedData.final_connections) {
                        if (Array.isArray(importedData.final_connections) &&
                            importedData.final_connections.every(row => Array.isArray(row))) {
                            final_connections = importedData.final_connections;
                        } else {
                            throw new Error('Invalid format for final_connections');
                        }
                    }

                    if (importedData.path_elevations) {
                        if (Array.isArray(importedData.path_elevations) &&
                            importedData.path_elevations.every(row => Array.isArray(row))) {
                            path_elevations = importedData.path_elevations;
                        } else {
                            throw new Error('Invalid format for path_elevations');
                        }
                    }

                    
                    // Handle lines (polylines)
                    if (importedData.lines) {
                        if (Array.isArray(importedData.lines)) {
                            // Clear existing lines
                            lines.forEach(line => line.setMap(null));
                            lines = [];
                    
                            // Add imported lines to the map
                            importedData.lines.forEach(lineData => {
                                const path = lineData.path.map(point => new google.maps.LatLng(point.lat, point.lng));
                                const polyline = new google.maps.Polyline({
                                    path: path,
                                    strokeColor: lineData.strokeColor,
                                    strokeOpacity: lineData.strokeOpacity,
                                    strokeWeight: lineData.strokeWeight,
                                    map: map // Assuming `map` is the Google Maps instance
                                });
                    
                                google.maps.event.addListener(polyline, 'click', function(e) {
                                    // Ensure startPoint and endPoint are properly initialized
                                        const startPoint = path[0];  // First point in the path
                                        const endPoint = path[path.length - 1]; // Last point in the path
                                        // Convert points to string to match keys in marker_index
                                        const startKey = `${startPoint.lat()},${startPoint.lng()}`;
                                        const endKey = `${endPoint.lat()},${endPoint.lng()}`;
                    
                                        // Initialize elevationData, dist, etc.
                                        const start_index = marker_index.get(startKey);
                                        const end_index   = marker_index.get(endKey);
                    
                                        if (start_index !== undefined && end_index !== undefined) {
                                            const elevationData = path_elevations[start_index][end_index]; // Ensure path_elevations is correctly defined
                                            const dist = distances[start_index][end_index]; // Ensure distances is correctly defined
                                            const labels = Array.from({ length: samples }, (_, k) => Math.floor((dist / (samples - 1) * k)));
                                            const initial_height = positions[start_index][2] + antenna_heights[start_index]; // Ensure positions is correctly defined
                                            const last_height = positions[end_index][2] + antenna_heights[end_index];
                                            const pathData = Array.from({ length: samples }, (_, k) => (((last_height - initial_height) / (samples - 1)) * k + initial_height));
                                            const fresnelData = Array.from({ length: samples }, (_, k) => (pathData[k] - (17.32 * Math.sqrt(((dist / (samples - 1) * k) * (dist - (dist / (samples - 1) * k)) * 0.06 / dist)))));
                    
                                            const contentString = `
                                                <div>
                                                    <br><b>Link information:</b></br>
                                                    <br> Distance: ${dist} Km</br>
                                                </div>
                                            `;
                                            showLineInfo(contentString, elevationData, fresnelData, pathData, labels);
                                        } else {
                                            console.warn('Start or end index is undefined in marker_index');
                                        }
                                    
                                });
                    
                                lines.push(polyline);
                            });
                        } else {
                            throw new Error('Invalid format for lines');
                        }
                    }
                    // Handle layers and their markers
                    
                    
                    total_labels = appGlobals.total_labels;
                    obligatory_nodes = appGlobals.obligatory_nodes;
                    marker_names = appGlobals.marker_names;
                    antenna_heights =  appGlobals.antenna_heights;
                    
                    alert('Variables and data imported successfully');
                } catch (error) {
                    console.error('Error parsing JSON or importing variables:', error);
                    alert('Failed to import variables. Please check the file format.');
                }
            };
            reader.readAsText(file);
        }
        let map = new google.maps.Map(document.getElementById("map-container"), {
            zoom: 6,
            center: position,
            mapTypeId: "roadmap", 
        });
        elevator = new google.maps.ElevationService();
        drawingManager = new google.maps.drawing.DrawingManager({
            drawingMode: google.maps.drawing.OverlayType.POLYLINE,
            drawingControl: false,
            polylineOptions: {
            strokeColor: '#ff0000',
            strokeWeight: 2,
            },
        });
        const controlDiv = document.createElement('div');
        const controlUI  = document.createElement('div');
        controlUI.classList.add('custom-map-control-button');
        controlUI.title     = 'Click to draw a line';
        controlUI.innerHTML = 'Draw Line';
        controlUI.addEventListener('click', () => {
            drawingModeEnabled = !drawingModeEnabled;
            controlUI.innerHTML = drawingModeEnabled ? 'Exit Draw Mode' : 'Draw Line';
        });
        controlDiv.appendChild(controlUI);
        controlDiv.index = 1;
        map.controls[google.maps.ControlPosition.TOP_CENTER].push(controlDiv);
        const slider = document.getElementById("distanceSlider");
        const output = document.getElementById("distanceValue");
        // Update the initial value
        output.textContent = slider.value;
        dist_thresh = parseInt(slider.value, 10);  // Convert to integer

        // Update the value dynamically as the slider is moved
        slider.oninput = function() {
            output.textContent = this.value;
            dist_thresh = parseInt(this.value, 10);  // Convert to integer
        };
        document.getElementById('new_project').addEventListener('click', function () {
            document.querySelector('.upload_csv_file').style.display = 'block';
            document.querySelector('.upload_kml_file').style.display = 'block';
            document.querySelector('#layer-control').style.display = 'block';
            document.querySelector('.dist_threshold').style.display = 'block';
            document.querySelector('.other_buttons').style.display = 'block';
            document.querySelector('.topology-container').style.display = 'block';
            document.querySelector('.download_button').style.display = 'block';
            document.querySelector('.customizenode').style.display = 'block';
            document.querySelector('.first-options').style.display = 'none';
            
        });
        document.getElementById('old_project').addEventListener('click', function () {
            new_project = false;
            document.querySelector('.upload_kml_file').style.display = 'block';
            document.querySelector('.upload_json_file').style.display = 'block';
            document.querySelector('.topology-container').style.display = 'block';
            document.querySelector('.download_button').style.display = 'block';
            document.querySelector('.customizenode').style.display = 'block';
            document.querySelector('.first-options').style.display = 'none';
            document.querySelector('.other_buttons').style.display = 'block';

        });


        document.getElementById('load_kml_file').addEventListener('click', function () {
            var fileInput = document.getElementById('file');
            var file = fileInput.files[0];
            if (!file) {
                alert('Please upload an XML file.');
                return;
            }
            if (file.name.endsWith('.kml')) {
                readXMLFile(file);
                document.querySelector('.upload_kml_file').style.display = 'none';
            } else {
                alert('Unsupported file type. Please upload an XML file.');
            }
            
        });

        document.getElementById('upload_csv_file').addEventListener('click', processCSVFile);

        document.getElementById('processLayers').addEventListener('click', async function () {
    
            // Retrieve the selected options from source and destination layers
            var selectedSourceLayers = ['Internet Source'];
            var selectedDestLayers = ['TOTEM-SA','SITEs','RDA'];
            const progressWrapper = document.getElementById("progress-wrapper");
            const progressBar = document.getElementById("progress-bar");
            const progressText = document.getElementById("progress-text");
            progressWrapper.style.display = "block";
           

            var source_markers = [];
            var dest_markers = [];
            var source_labels = [];
            var dest_labels = [];
        
            // Populate source_markers and source_labels based on the selected source layers
            for (let i = 0; i < selectedSourceLayers.length; i++) {
                source_markers = source_markers.concat(layers[selectedSourceLayers[i]]);
                source_labels = source_labels.concat(Array(layers[selectedSourceLayers[i]].length).fill(selectedSourceLayers[i]));
            }
            
            // Populate dest_markers and dest_labels based on the selected destination layers
            for (let j = 0; j < selectedDestLayers.length; j++) {
                dest_markers = dest_markers.concat(layers[selectedDestLayers[j]]);
                console.log(dest_markers);
                console.log(layers[selectedDestLayers[j]])
                dest_labels = dest_labels.concat(Array(layers[selectedDestLayers[j]].length).fill(selectedDestLayers[j]));
            }
        
            // Combine all labels into a single array
            total_labels = [...source_labels, ...dest_labels];
            // Create a map that holds arrays of positions for each label
            
            for (let i = 0; i < total_labels.length; ++i) {
                if (layers_positions[total_labels[i]] !== undefined && layers_positions[total_labels[i]].length !== 0) {
                    positions = positions.concat(layers_positions[total_labels[i]]);
                }
                delete layers_positions[total_labels[i]]; // Prevent duplication in subsequent iterations
                
                if (layers_positions_map[total_labels[i]] !== undefined && layers_positions_map[total_labels[i]].length !== 0) {
                    positions_map = positions_map.concat(layers_positions_map[total_labels[i]]);
                }
                delete layers_positions_map[total_labels[i]]; // Prevent duplication in subsequent iterations
                if (markers_name_per_layer[total_labels[i]] !== undefined && markers_name_per_layer[total_labels[i]].length !== 0) {
                    marker_names = marker_names.concat(markers_name_per_layer[total_labels[i]]);
                }
                delete markers_name_per_layer[total_labels[i]]; // Prevent duplication in subsequent iterations

                if (antenna_heights_per_layer[total_labels[i]] !== undefined && antenna_heights_per_layer[total_labels[i]].length !== 0) {
                    antenna_heights = antenna_heights.concat(antenna_heights_per_layer[total_labels[i]]);
                }
                delete antenna_heights_per_layer[total_labels[i]]; // Prevent duplication in subsequent iterations
            }
            
            
            console.log(positions);
            console.log(positions_map);
            console.log(marker_names);
            let rounded_map = new Map();
            for (let i = 0 ; i < positions.length; ++i){
                const l1 = positions_map[i].lat;
                const l2 = positions_map[i].lng;
                let key = `${l1},${l2}`;
                const rounded_l1 = parseFloat(l1.toFixed(5));
                const rounded_l2 = parseFloat(l2.toFixed(5));
                marker_index.set(key, i);
                key = `${rounded_l1},${rounded_l2}`;
                rounded_map.set(key, i);
            }

            console.log(marker_index)
            for (let [key, value] of hauteur_map.entries()) {
                console.log(key);
                console.log(Array.from(rounded_map.keys()));

                let ht_index = rounded_map.get(key);
                console.log(ht_index);  // Accessing the value from marker_index map
                if (ht_index !== undefined) {  // Ensure the index exists
                    antenna_heights[ht_index] = value;
                    console.log(antenna_heights[ht_index]);  // Use value from hauteur_map
                }
            }

            const progressSource = new EventSource('http://127.0.0.1:3000/progress');
            progressSource.onmessage = function (event) {
                try {
                    const progress = JSON.parse(event.data).percentage;
                    progressText.textContent = `${Math.round(progress)}%`;
                    progressBar.style.width = `${Math.round(progress)}%`;
                } catch (e) {
                    console.error('Error parsing progress update:', e);
                }
            };
            
            progressSource.onerror = function () {
                console.error("Error receiving progress updates");
                progressSource.close();
            };


            await fill_matrices();
            console.log("Matrices filled, proceeding to compute possible links");
            progressWrapper.style.display = "none";

        
            // Combine all markers into a single array and calculate possible links
            total_markers = [...source_markers, ...dest_markers];
            sz_src = source_markers.length;
            node_capacities = [];
            for (let i = 0; i < total_labels.length; ++i) {
                if (total_labels[i] === 'Internet Source') {
                    node_capacities.push(2000);
                } else if (total_labels[i] === 'RDA') {
                    node_capacities.push(1);
                } else if (total_labels[i] === 'SITEs') {
                    node_capacities.push(1);
                } else {
                    node_capacities.push(0);
                }
            }
            console.log(node_capacities);
            console.log("computing possible_connections")
            final_connections = await possible_links(sz_src);
            // Logging the selections and total connections
            console.log('Selected Source Layers:', selectedSourceLayers);
            console.log('Selected Destination Layers:', selectedDestLayers);
            console.log('Total Connections:', final_connections);
        });

        
        document.getElementById('generate-topology').addEventListener('click', handleGenerateTopology);
        document.getElementById('customize_heights').addEventListener('click', () => {
            // Example: Selecting the first marker in the list for demonstration
            
            marker2update = true;
        });
        document.getElementById('close-line-info').addEventListener('click', function() {
            document.getElementById('line-info').style.display = 'none';
        });  
        document.getElementById('exportToFile').addEventListener('click', save_and_export);
        document.getElementById('importButton').addEventListener('click', () => {
            document.getElementById('importFromFile').click();
        });
        document.getElementById('importFromFile').addEventListener('change', importFromFile);
    }

    document.getElementById('generate-characteristics').addEventListener('click', function() {
        // Display the modal
        document.getElementById('myModal').style.display = 'block';
        document.getElementById('myModal').offsetHeight;
    
        // Populate the table with antenna data (replace with your actual data source)
        var antennaData = [];
        for (var i = 0; i < positions.length; i++) {
            antennaData.push({
                "Node Id": i,
                "Name": marker_names[i],
                "Router Type": router_type[i],
                "Roles": roles[i],
                "Horizontal Azimuth": horizontal_azimuths[i] !== 0 ? horizontal_azimuths[i] : "-",
                "Vertical Azimuth": vertical_azimuths[i] !== 0 ? vertical_azimuths[i] : "-",
            });
        }
        console.log("Antenna Data:", antennaData); // Debugging: Check if data is populated
    
        var tableBody = document.getElementById('antennaTableBody');
        tableBody.innerHTML = ''; 
        console.log("Table body cleared"); // Debugging
    
        // Populate the table with antenna data
        antennaData.forEach(function(antenna) {
            var row = document.createElement('tr');
    
            var nodeIdCell = document.createElement('td');
            nodeIdCell.textContent = antenna['Node Id'];
            row.appendChild(nodeIdCell);

            var positionsCell = document.createElement('td');
            positionsCell.textContent = antenna['Name'];
            row.appendChild(positionsCell);

            var typeCell = document.createElement('td');
            typeCell.textContent = antenna['Router Type'];
            row.appendChild(typeCell);
    
            var roleCell = document.createElement('td');
            roleCell.textContent = antenna['Roles'];
            row.appendChild(roleCell);
    
            var horizontalAzCell = document.createElement('td');
            horizontalAzCell.textContent = antenna['Horizontal Azimuth'];
            row.appendChild(horizontalAzCell);
    
            var verticalAzCell = document.createElement('td');
            verticalAzCell.textContent = antenna['Vertical Azimuth'];
            row.appendChild(verticalAzCell);
    
    
            tableBody.appendChild(row);
            console.log("Appended row:", row); // Debugging
        });
    
        // Toggle the visibility of the table (optional)
        var table = document.getElementById('antennaTable');
        table.style.display = 'table';
        
    });

    // Close the modal when the user clicks on <span> (x)
    document.querySelector('.close').addEventListener('click', function() {
        document.getElementById('myModal').style.display = 'none';
    });
    
    // Close the modal if the user clicks outside of it
    window.addEventListener('click', function(event) {
        if (event.target === document.getElementById('myModal')) {
            document.getElementById('myModal').style.display = 'none';
        }
    });
    
</script>
</body>
</html>


